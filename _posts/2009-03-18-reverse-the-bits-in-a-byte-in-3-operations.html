---
layout: post
title: Reverse the Bits in a Byte in 3 operations
date: 2009-03-18 15:39:44.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags:
- Bitwise
- Optimization
- Programming
meta:
  _edit_last: '1'
  tmac_last_id: '166390249818296320'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1543647808;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:535;}i:1;a:1:{s:2:"id";i:704;}i:2;a:1:{s:2:"id";i:754;}}}}
author:
  login: Philihp
  email: philihp@gmail.com
  display_name: Philihp
  first_name: ''
  last_name: ''
---
<p>This is among many brilliant hacks from <a href="http://graphics.stanford.edu/~seander/bithacks.html#ReverseByteWith64BitsDiv">this</a> page.</p>
<pre>b = (b * 0x0202020202ULL & 0x010884422010ULL) % 1023;</pre>
<blockquote><p>The multiply operation creates five separate copies of the 8-bit byte pattern to fan-out into a 64-bit value. The AND operation selects the bits that are in the correct (reversed) positions, relative to each 10-bit groups of bits. The multiply and the AND operations copy the bits from the original byte so they each appear in only one of the 10-bit sets. The reversed positions of the bits from the original byte coincide with their relative positions within any 10-bit set. The last step, which involves modulus division by 2^10 - 1, has the effect of merging together each set of 10 bits (from positions 0-9, 10-19, 20-29, ...) in the 64-bit value. They do not overlap, so the addition steps underlying the modulus division behave like or operations. </p></blockquote>
<p>The genius here, I think, is the modulus division to compress eight specific bits from a 64-bit number down into an 8-bit byte.</p>
