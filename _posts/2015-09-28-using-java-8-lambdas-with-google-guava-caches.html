---
layout: post
title: Using Java 8 Lambdas with Google Guava Caches
date: 2015-09-28 08:12:38.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags:
- cache
- Google
- guava
- java8
- lambda
- Programming
meta:
  _edit_last: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1543971403;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:184;}i:1;a:1:{s:2:"id";i:946;}i:2;a:1:{s:2:"id";i:988;}}}}
author:
  login: Philihp
  email: philihp@gmail.com
  display_name: Philihp
  first_name: ''
  last_name: ''
---
<p>With Guava, you can define a simple in-memory cache with</p>
<pre lang="java">
import static java.util.concurrent.TimeUnit.DAYS;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

Cache<K, V> cache =
    CacheBuilder.newBuilder()
        .maximumSize(100000)
        .expireAfterAccess(7, DAYS)
        .build();</pre>
<p>With this you can use .put(K, V) to load values, and .getIfPresent(K), which returns null if the key isn't present. Sometimes it's more convenientÂ to use <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/Cache.html#get(K,%20java.util.concurrent.Callable)">get(K key, Callable&lt;? extends V&gt; valueLoader)</a>, where the valueLoader is called on a cache miss, and populates the cache and gives you what a cache hit would have given you. The <a href="https://github.com/google/guava/wiki/CachesExplained#from-a-callable">old Java 7 way</a> of doing this was really ugly:</p>
<pre lang="java">cache.get(key, new Callable() {
    @Override
    public V call() {
        return calculatedValue(key);
    }
});</pre>
<p><a href="https://xkcd.com/1513/">Don't write ugly code</a>. With Java 8 Lambdas, just do this:</p>
<pre lang="java">cache.get(key, () -> {
    calculatedValue(key);
}</pre>
