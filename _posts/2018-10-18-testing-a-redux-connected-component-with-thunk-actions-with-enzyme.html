---
layout: post
title: Testing a Redux Connected Component with Thunk Actions with Enzyme
date: 2018-10-18 07:31:45.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags:
- dispatch
- enzyme
- jest
- Programming
- react
- redux
- test
- thunk
meta:
  _edit_last: '1'
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1543972042;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:1469;}i:1;a:1:{s:2:"id";i:754;}i:2;a:1:{s:2:"id";i:1014;}}}}
  medium_post: O:11:"Medium_Post":11:{s:16:"author_image_url";N;s:10:"author_url";N;s:11:"byline_name";N;s:12:"byline_email";N;s:10:"cross_link";N;s:2:"id";N;s:21:"follower_notification";N;s:7:"license";N;s:14:"publication_id";N;s:6:"status";N;s:3:"url";N;}
author:
  login: Philihp
  email: philihp@gmail.com
  display_name: Philihp
  first_name: ''
  last_name: ''
---
<p>Let's say you've got a React component connected to a Redux store</p>
<pre>
import React from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import { saveColor } from '../actions/save';
import ColorButtons from '../components/ColorButtons';

const ColorButtons = ({ colors, onClick }) => (
  &lt;div&gt;
    {colors.map(color => {
      &lt;button type="button" key={color} onClick={onClick(color)}&gt;{color}&lt;/button&gt;
    })}
  &lt;/div&gt;
);

ColorButtons.propTypes = {
  colors: PropTypes.arrayOf(PropTypes.string),
  onClick: PropTypes.func.isRequired,
};

const mapStateToProps = state => ({
  colors: state.colors || [],
});

const mapDispatchToProps = dispatch => ({
  onClickColor: color => () => {
    dispatch(saveColor({ color }));
  },
});

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(ColorButtons);
</pre>
<p>Which calls this action creator.</p>
<pre>
export const SAVE_COLOR = 'SAVE_COLOR';
export const saveColor = ({ color }) => ({
  type: SAVE_COLOR,
  color,
});
</pre>
<p>Everything works great in your smoke tests. How do you write unit tests for this? One way would be to expose mapStateToProps and mapDispatchToProps by exporting them (see <a href="https://jsramblings.com/2018/01/15/3-ways-to-test-mapStateToProps-and-mapDispatchToProps.html">jsramblings.com</a>). This is indeed smelly, though <a href="https://github.com/reduxjs/redux/blob/master/docs/recipes/WritingTests.md#connected-components">Redux documentation</a> suggests doing something similar, but this is something I disagree with, because your tests now assume that connect will be called on the exposed internal. What if the signature for connect changes? What if someone makes a change that messes with what's passed to connect()? That's now untested.</p>
<hr />
<h3>Why even testÂ it?</h3>
<blockquote><p>It is not necessary to test that our mapDispatchToProps is properly passing a function (login, submit, click etc.) to the connected component, because Redux is already responsible for this. [<a href="https://willowtreeapps.com/ideas/best-practices-for-unit-testing-with-a-react-redux-approach">willowtreeapps.com</a>]</p></blockquote>
<p>I disagree with the above quote. It is true that Redux is responsible for it, and we make an assumption that it will continue to function properly. Tests are meant to outsource the cognitive load of maintaining assumptions after every change and library upgrade. What happens when we upgrade Redux, and they change the signature of connect()?</p>
<p>We have A &rarr; B &rarr; C, and B is private. They suggest exposing B, and testing B &rarr; C, but instead we should have a test that A &rarr; C.</p>
<hr />
<p>I prefer actually rendering the component, and checking to make sure it still connects as expected. This is not an expensive test.</p>
<pre>
import React from 'react';
import { shallow } from 'enzyme';
import configureStore from 'redux-mock-store';
import ColorButtons from '../ColorButtons';
import { saveColor } from '../../actions/save';

const buildStore = configureStore();

describe('ColorButtons', () => {
  let store;
  let wrapper;
  const initialState = { colors: ['red', 'blue'] };

  beforeEach(() => {
    store = buildStore(initialState);
    wrapper = shallow(<colorbuttons store="{store}" />);
  });

  it('passes colors from state', () => {
    expect(wrapper.props().colors).toBe(initialState.colors);
  });

  it('can click yellow', () => {
    const color = 'yellow';
    wrapper.props().onClick(color)();
    expect(store.getActions()).toContainEqual(saveColor({ color }));
  });
});
</pre>
<p>The first test checks to make sure the array available to wrapper.props() is the same array as that one stored in initialState.colors.</p>
<p>The second test makes sure that the store gets an action dispatched to it. It's not necessary to check to make sure the store digested and reduced the action into the state; you're not testing the reducers here.</p>
<h3>What if the component calls a Thunk action?</h3>
<p>This will work for about 20% of your components, but if you ever want to call some async action, you'll probably dispatch a thunk action. That is, some of your actions will instead return functions that take dispatch. From the connected controller, they look the same, but the action looks slightly different. Say our mapDispatchToProps now looks like this contrived example</p>
<pre>
const mapDispatchToProps = dispatch => ({
  onClickColor: color => () => {
    dispatch(<b>storeColor</b>({ color }));
  },
});
</pre>
<p>And the actions now look like this</p>
<pre>
export const saveColor = ({ color }) => ({
  type: SAVE_COLOR,
  color,
});

export const <b>storeColor</b> = ({ color }) => <b>dispatch =></b> {
  dispatch(saveColor());
  return axios.patch('/api/color.json', { color })
    .then(response => {
      // another dispatched action maybe?
    });
</pre>
<p>If you tried to test this as-is, you'd get the error</p>
<pre>
Actions must be plain objects. Use custom middleware for async actions.
  26 |   onClick: color => () => {
> 27 |     dispatch(storeColor({ color }));
     |     ^
  28 |   },
  29 | });
</pre>
<h3>Actions must be plain objects. Use custom middleware for async actions.</h3>
<p>This is because your test's mock-store isn't configured with Thunk middleware. Configure it like this:</p>
<pre>
import React from 'react';
import { shallow } from 'enzyme';
import thunk from 'redux-thunk';
import configureStore from 'redux-mock-store';
import ColorButtons from '../ColorButtons';
import { saveColor } from '../../actions/save';

const buildStore = configureStore([thunk]);

describe('ColorButtons', () => {
  let store;
  let wrapper;
  const initialState = { colors: ['red', 'blue'] };

  beforeEach(() => {
    store = buildStore(initialState);
    wrapper = shallow(<colorbuttons store="{store}" />);
  });

  it('passes colors from state', () => {
    expect(wrapper.props().colors).toBe(initialState.colors);
  });

  it('can click yellow', () => {
    const color = 'yellow';
    wrapper.props().onClick(color)();
    expect(store.getActions()).toContainEqual(saveColor({ color }));
  });
});
</pre>
<p>Now your test will dispatch just fine. Ship it!</p>
