---
layout: post
title: Avoid Correlated Subqueries
date: 2008-09-16 03:58:00.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags:
- Optimization
- Programming
- SAS
- SQL
meta:
  blogger_blog: philihp.blogspot.com
  blogger_author: Philihp Busbyhttp://www.blogger.com/profile/16640093851362468089noreply@blogger.com
  blogger_permalink: "/2008/09/if-your-sql-code-has-nested-select-that.html"
  _edit_last: '1'
  tmac_last_id: '166390268189356032'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1543535320;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:582;}i:1;a:1:{s:2:"id";i:1144;}i:2;a:1:{s:2:"id";i:992;}}}}
author:
  login: Philihp
  email: philihp@gmail.com
  display_name: Philihp
  first_name: ''
  last_name: ''
---
<p>If your SQL code has a nested select that references a column in an outer select, such as the following, it may be possible to rewrite to perform orders of magnitude faster.<br />
<code>proc sql;<br />
   create table new_rates as<br />
   select<br />
     from work.exchange_rate n<br />
     where not exists(<br />
       select  from imf.exchange_rate o<br />
       where n.effective_date=o.effective_date and n.iso_char_code=o.iso_char_code );</p>
<p><span style="color: #0000FF">NOTE: Table WORK.NEW_RATES created, with 49 rows and 4 columns.</span></p>
<p> quit;</p>
<p><span style="color: #0000FF">NOTE: PROCEDURE SQL used (Total process time):<br />
     <strong>real time           8.83 seconds</strong><br />
     cpu time            8.65 seconds</span></code><br />
Here, the table imf.exchange_rate has 13416 rows, covering exchange rates at close, daily, for 39 different currencies, over nearly 1 year. Modest, but fairly small. It has no indexes, and has not been sorted (or marked as sorted). work.exchange_rate is a smaller version of it, covering only exchange rates for the last month, with 980 rows. The query is trying to return any exchange rates that we didn't have before.</p>
<p>Should be simple right? There's no reason for it to take this long. By rewriting the query to do a left join, below, SAS merges the tables behind the scenes, then finishes the query in a single scan.<br />
<code>proc sql;<br />
   create table new_rates as<br />
   select n.*<br />
     from work.exchange_rate n<br />
       left join imf.exchange_rate o<br />
         on (n.effective_date = o.effective_date and n.iso_char_code = o.iso_char_code)<br />
     where o.iso_char_code = '';</p>
<p><span style="color: #0000FF">NOTE: Table WORK.NEW_RATES created, with 49 rows and 4 columns.</span></p>
<p> quit;</p>
<p><span style="color: #0000FF">NOTE: PROCEDURE SQL used (Total process time):<br />
     <strong>real time           0.13 seconds</strong><br />
     cpu time            0.13 seconds</span></code></p>
