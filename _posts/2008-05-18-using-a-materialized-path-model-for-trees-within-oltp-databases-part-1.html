---
layout: post
title: Using a Materialized Path Model for Trees within OLTP Databases (part 1)
date: 2008-05-18 08:24:00.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags:
- Programming
- SQL
meta:
  _edit_last: '1'
  blogger_blog: philihp.blogspot.com
  blogger_author: Philihp Busbyhttp://www.blogger.com/profile/16640093851362468089noreply@blogger.com
  blogger_permalink: "/2008/05/using-materialized-path-model-for-trees.html"
  tmac_last_id: '166390277290983425'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1543617399;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:566;}i:1;a:1:{s:2:"id";i:1013;}i:2;a:1:{s:2:"id";i:992;}}}}
author:
  login: Philihp
  email: philihp@gmail.com
  display_name: Philihp
  first_name: ''
  last_name: ''
---
<p>Databases are very very good at storing tabular, dimensional data; and in a world where everything is a spreadsheet (your finance department), this works very well. Often, though, there's a need for an application to store and deal with a tree of data; such as in classification systems or management structures. The <a href="http://en.wikipedia.org/wiki/Library_of_Congress_Classification">Library of Congress</a>, the <a href="http://en.wikipedia.org/wiki/Dewey_Decimal_Classification">Dewey Decimal System</a>, and <a href="http://www.census.gov/epcd/naics02/naicod02.htm">NAICS</a> all come to mind. Anyone who's ever been working with their company's employee data has certainly come across the management hierarchy. In each of these, you've got a tree of nodes, each node (except the top; the tree root) having at most one parent, and each node (except those on the bottom; the leaves) having any number of children.
<pre>          [node]<br />         /      <br />     [node]    [node]<br />      /           <br /> [node]  [node]   [node]<br />                      <br />                     [node]</pre>
<p>In a properly normalized <a href="http://en.wikipedia.org/wiki/OLTP">OLTP</a> database, what people usually do is create a table structure where each node only knows his parent. This satisfies the requirement of database normalization to have each fact/idea in one and only one location so that there can't possibly be a conflict (aside: this doesn't guarantee that there can't be conflicts. Node A could say node B is its parent, and node B could say node A is its parent).</p>
<p>This is called the <b>Adjacency Model</b>, since it is clear when two records are adjacent siblings; they share the same parent.</p>
<p>The way this looks as far as table schema would be
<pre>+--------------+<br />| NODE         | <---.<br />+--------------+     |<br />| node_id      |     |<br />| parent_id    | ----'<br />| node_data... |<br />+--------------+</pre>
<p>The other day I was asked how one could quickly query the database the question "How do I find all of the direct and indirect children of a node?"</p>
<p>Direct children are simple...
<pre>SELECT *<br />  FROM node<br />  WHERE parent_id = ?</pre>
<p>Children of children of a node is also simple...
<pre>SELECT *<br />  FROM node<br />  WHERE parent_id = ?<br />    OR parent_id in (<br />      SELECT node_id<br />        FROM node<br />        WHERE parent_id = ?)</pre>
<p>But this gets out of hand pretty quickly, and it becomes obvious we won't be able to have a single, simple, fast query that gives ALL children of a node, no matter how far down their ancestry.</p>
<p><a href="http://www.amazon.com/exec/obidos/ASIN/0596008945"><b>Enter the Materialized Path Model</b></a></p>
<p>In a Materialized Path model, each row of your table knows its entire ancestry. It's a little like if every file on your file system knew its entire path, rather than just the folder it was in.</p>
<p>Probably the best way to describe it is by example. Say we had this tree:
<pre>             0<br />           / | <br />          1  2  3<br />         /  / <br />        4  5   6<br />              /|<br />             7 8 9</pre>
<p>In an adjacency model, our table looks like:
<pre>+---------+-----------+<br />| node_id | parent_id |<br />+---------+-----------+<br />| 0       | .         |<br />| 1       | 0         |<br />| 2       | 0         |<br />| 3       | 0         |<br />| 4       | 1         |<br />| 5       | 2         |<br />| 6       | 2         |<br />| 7       | 6         |<br />| 8       | 6         |<br />| 9       | 6         |<br />+---------+-----------+</pre>
<p>However in a materialized path model, we would store this as
<pre>+---------+-------+<br />| node_id | path  |<br />+---------+-------+<br />| 0       |       |<br />| 1       | 1     |<br />| 2       | 2     |<br />| 3       | 3     |<br />| 4       | 1.4   |<br />| 5       | 2.5   |<br />| 6       | 2.6   |<br />| 7       | 2.6.7 |<br />| 8       | 2.6.8 |<br />| 9       | 2.6.9 |<br />+---------+-------+</pre>
<p>In order to ask the database "which nodes are children of <i>x</i>" you can query with
<pre>SELECT *<br />  FROM node<br />  WHERE path LIKE<br />    (SELECT path<br />       FROM node<br />       WHERE node_id = <i>x</i>)||'%'</pre>
<p>In some languages, the "begins with" operation is optimized. MySQL can use regular expressions. SAS has the <code>=:</code> operator.</p>
<p>This model lends itself to other nice things; finding the depth of a node can be calculated on the number of dot delimiters in the path.</p>
<p>The Materialized Path model works very well as opposed to the Adjacency model when the root node, and nodes with deep ancestry rarely change; which is usually the case in classification schemes (base categories tend to be the established ones) and company org hierarchies (upper level executive managers tend to be senior).</p>
<p>We can do a little bit better with a materialized path model, though... More in Part 2.<br /><!--<br />part 2:</p>
<p>standardize the length of each element in the path for depth calc<br />no need for delimiters now</p>
<p>part 3:</p>
<p>disconnect using the ID, instead use a letter<br />letters don't have to be unique to the table, just the last element has to be unique<br />  for all the direct reports of that record's manager<br />by using alphanumerics, support up to 62 direct reports<br />--></p>
